\unnumberedSection[designDetails]{Design Details}
Briefly speaking, we can describe our architecture as the combination of two main patterns which are: \gls{ecs} Pattern and \gls{mvc} Pattern. Nonetheless, other patterns are omnipresent in the project such as the Singleton Pattern and the Observer Pattern. Moreover, we also used the Strategy Pattern and the Single Instance Pattern. In the following, we are going to explain how those patterns serve the architecture, the advantages and their drawbacks. \\

\unnumberedSubsection[ecs]{Entity-Component-System Pattern}
First of all, the \gls{ecs} pattern is known as being the pattern by excellence for game development. As discussed previously, the use of this pattern is a game changer when it comes to performance, flexibility and modifiability. However, its use also presents a lot of challenges starting by understanding it! Comparatively to traditional object oriented patterns, the \gls{ecs} pattern promote the composition-over-inheritance. In other words, this means that \gls{ecs} eradicate the need for a deep inheritance tree usually necessary to represent all the game objects. Whoever that has ever developed under the object oriented paradigm knows that creating deep hierarchies is only synonym of problems. In fact, deep hierarchies are hard to understand, maintain and expends. Per example, a simple new feature could necessitate the refactoring of more than half of the hierarchical tree without considering the code duplication that it may produce in diverging branches. This problem is really frequent with games where a lot of objects having similar characteristics but also important differences in their behavior have to interact with each other. \\

With \gls{ecs}, the deep hierarchy is replaced by a simple model where each entity is made out of an archetype which corresponds to a composition of one or many components. Each of those components confers new functionalities to the given entity in a seamless way. The components have two main purposes, storing the data (attributes) and identifying what kind of entity we are currently processing. In addition to entities and components, the pattern defines systems that are responsible for the processing of the entities. Those systems filter the entities that are going to be processed by defining a mask which can be defined as a list of components required by this system for the entities to be eligible. At runtime, during each game loop, the different entities will be passed to the systems for which they are eligible which will update their state and attributes. \cite{wiki:ecs} \\

\unnumberedSubsection[mvc]{Model-View-Controller Pattern}
Another famous pattern for game development is the \gls{mvc} pattern. Actually, the \gls{mvc} pattern is an unavoidable pattern for every software with a \gls{ui}. Without presenting clear drawbacks, this pattern allows the creation of a clear separation of the interface and the model. Having such a separation makes it easier to change the model without having to reflect these changes everywhere else in the views which are connected to a fixed interface defined by the controllers. One could argue that controllers tend to evolve as god classes. Yet, this may simply reflect an insufficient segmentation of the model into closely related functionalities and the laziness of creating multiple controllers serving specific purpose. It is also not so rare to define the controllers as Singleton classes (see \nameref{subsec:singleton}) to avoid the need of passing references on those controllers all around and makes them generally accessible. \cite{wiki:mvc} \\

The most difficult part of this pattern is actually to remember that it exists. Too often, well established \gls{mvc} structure at the beginning of a project end up completely useless after only couple of features implemented because do not pay attention to create the appropriate indirection between the model and the views.

\unnumberedSubsection[singleton]{Singleton Pattern}
Another widely used pattern into our architecture is the Singleton pattern. Even if most of people opt for the implementation of a singleton pattern to make sure only one instance of a given class will exist at the same time, the real advantage of this pattern over a simple Single Instance Pattern is to be able to access the single instance from anywhere in the application. \cite{wiki:singleton} \\

Despite the fact that this pattern has been really popular by the past, current trend towards \gls{tdd} brought with him an important shadow over this pattern. Obviously, the use of the singleton pattern, make the creation of unit tests really cumbersome and unreliable. The core principle of unit testing relate on the fact that all tests should be independent from each other. The introduction of a singleton instance break this principle by making all the tests depending on a common instance. \\

This is why most of developers will now use the Single Instance Pattern in replacement of the old but gold singleton pattern. Actually, if a general access to the singleton instance is not required by the design, it is recommended to switch to a single instance pattern. \cite{singletonVSsingleInstance}

\unnumberedSubsection[observer]{Observer Pattern}
The Observer Pattern is also omnipresent into our architecture. Without having implementing an observer pattern from a to z, we indirectly use it every-time we set listeners over any given instance. The observer pattern is particularly useful for interactive \gls{ui} elements. The main advantage of the Observer Pattern is to delegate the processing of events to the party that is the most aware of their occurrence. \\

If we use a button as an example, it will be inefficient and imprecise to keep a flag recording if the button as actually been clicked and then wait for the processing instance to look if the given flag is activated, process the event and reset the flag. In addition to produce a lot of unnecessary calls, such an approach may loose inputs during the process and offer slow response rate. It is way more efficient to inform the subject in advance of the observer intent and let him call the observer when the expected event occurs. \\

The disadvantage of this pattern is the high coupling created between the observer and the subject. This is not such a big problem when the information passed to the subject is only an indirection, but a bad practice is often to directly write a full procedure into those listeners leading to code duplication and less flexible architecture. \cite{wiki:observer}

\unnumberedSubsection[strategy]{Strategy Pattern}
The last pattern used in our architecture is the strategy pattern. On the same line of thought as the \gls{ecs} pattern, the strategy pattern try to avoid using clear hierarchical structure to define the specialized classes. With this pattern, different interfaces corresponding to different behavior are defined. Based on the desired behavior the specialized classes can choose which behavior they need. \cite{wiki:strategy} \\
