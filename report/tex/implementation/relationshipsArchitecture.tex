\unnumberedChapter[relationshipsArchitecture]{Relationships with Architecture}

This should list the inconsistencies between your architecture and the implementation. Give the reasons for these inconsistencies. Discuss whether they could have been discovered at an earlier point, for instance during the ATAM evaluation.\\


\unnumberedSubsection[atam_feedback]{ATAM Feedback}

During the feedback we recieved from the other group on our architecture, they were insisting that implement the ECS architecture would have a negative effect on the performance of our game. This didnâ€™t make sence based on the research we had done for the project, and would prove to be false when we are now done implementing it. The performance and modifiability of our game is very high, due to the fact we utilized Artemis-odb as the framework for our ECS.


\unnumberedSection[arch_patterns]{Architectural Patterns}

In our architecture we decided on several patterns to be used for the implementation. We chose three architectural patterns:


\begin{description}
	\item [ECS] We were able to fully implement the ECS architecture for our game world, using Artemis-odb
	\item [P2P] We were able to fully implement the peer-to-peer tactic for networking, using google play service to host the room creation and setup the connections between the devices.
	\item [MVC] We were able to fully implement the MVC to separate game logic, rendering of the view and the controls of the game. Some minor inconsistencies were made in the GameScreen, but these minor infractions were insignificant enough for us to be satisfied with the result.
\end{description}

\unnumberedSection[design_patterns]{Design Patterns}

In addition we chose two design patterns:

\begin{description}
	\item [Singleton] We were able to fully implement the singleton pattern in several classes in our project, being NetworkManager, Assets and AudioPlayer.
	\item [Observer] We were able to fully implement the Observer technique. This was mainly utilized in our PlayService, as the game had to listen to when different people connected and disconnected to rooms, so the views would be correct and make sure the game logic behaved as expected in multiplayer.
\end{description} .

During the implementation phase we stayed consistent and followed the choices we made in the architectural phase. All the chosen patterns are implemented in the final game and we are satisfied with how we originally drafted the patterns for the implementation.

\unnumberedSection[views]{Views}
Next we will go over the views from the architecture and discuss if there are any inconsistencies with the final implementation of the game.

\begin{description}
	\item[logical view] The logical view shown in \autoref{fig:logicalView} matches our final implementation almost perfectly
	\item[domain model] The domain model shown in \autoref{fig:domainModel} is largely inconsistent with the final implementation. This is mainly because of an incomplete understanding of the ECS pattern during the drafting of the architecture. The domain model shown here follows the standard object oriented paradigm, which is replaced by the ECS pattern in the game logic for our project.
	\item[process view] The process view shown in \autoref{fig:processView} has been reduced in scope in the final implementation. We had insufficient time to implement all features. In the final version the tutorial, achievements and highscores are missing. There is also no singleplayer, the game plays in multiplayer by default. Choosing a character is not possible. The game also does not show results after the match.
	\item[character FSM] The FSM for character entities shown in \autoref{fig:fsmCharacter} is largely consistent with the final game. However in the final version we have not implemented a revive function. If you die the game is over...
	\item[wall FSM] The wall FSM  shown in \autoref{fig:fsmWalls} is correct for the final version of the game.
	\item[development view] The development view shown in \autoref{fig:developmentView} mostly reflects the implementation of the final game. However the screens for character selection, results, highscores and achievements are not included. The Lobby screen was also not necessary because this was provided by the Google Play Game Services API. The corresponding controllers for the missing screens are also absent from the final game.
	\item[physical view] The physical view shown in \autoref{fig:physicalView} is consistent with the final game except for the database with the achievements. We did not implement achievements and thus also did not need any database for achievements.
\end{description}

\AddPicture[logicalView]{1}{0.35}{logicalView}{The logical view of the \textit{Bomb Hunt} game}

\AddPicture[domainModel]{1}{0.4}{domain}{The domain model of the \textit{Bomb Hunt} game}

\AddPicture[processView]{1}{0.25}{fsmScreens}{The process view of the \textit{Bomb Hunt} game}

\AddPicture[fsmCharacter]{1}{0.25}{fsmCharacter}{The \gls{fsm} for character entities}

\AddPicture[fsmWalls]{0.8}{0.25}{fsmWalls}{The \gls{fsm} for wall entities}

\AddPicture[developementView]{1}{0.35}{developmentModel}{The development view of the \textit{Bomb Hunt} game}

\AddPicture[physicalView]{1}{0.35}{deployment}{The physical view of the \textit{Bomb Hunt} game}

\unnumberedSubsection[conclusion]{Conclusion on consistency}

In general we can say that most of our inconsistencies are a result of underestimating the amount of work required to implement all features. We did not have to change any decisions we made in the architectural phase but we had to leave out a lot of features and thus parts of the architecture because of time constraints. We learned a good lesson in realizing how much work it takes to implement extra features.
