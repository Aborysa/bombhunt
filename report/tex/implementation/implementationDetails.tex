\unnumberedSection[implementationDetails]{Implementation Details}

\unnumberedSubsection[ecsImplementation]{Entity-Component-System Pattern}
To implement the \gls{ecs} pattern, we used the \texttt{Artemis-odb} framework.\cite{artemis-odb} This framework is generally recognized for its performance and maturity. Additionally, this framework is actively maintained and continuously upgraded. Among all the patterns used in this game, the \gls{ecs} pattern is definitely the most powerful of all of them. Without the use of this pattern, the development of such a complex game would never have been possible in a so short period of time. \\

Because a graphic worth more than 10 pages of text, we took the time to create the \autoref{fig:ecs} which give a visual overview of the different components, systems and archetypes (entities) defined in the model layer.

\AddPicture[ecs]{1}{1}{ecs.png}{Archetype composition, System masks and component listing for the ECS pattern}

There is not much to say about how we implemented this pattern since we mostly just followed the structure established by the \textit{Artemis-odb} framework which is really close to any standard \gls{ecs} framework. We can however mention few considerations that we would normally have to be reviewed before making our game a commercial and professional product. The first one would be to make a better use of the aspects to filter the entities. For the moment, the aspects have only been used to filter the entities to be processed by each system. We should also have used this logic to detect entities at a specific grid position. Instead, we created our own methods to pull all the entities and check if they correspond to what we are looking for. The second error we made is to initialize the \gls{ecs} world inside the \texttt{GameScreen} because of early stage lack of refactoring and peer-reviewing. Obviously, that design decision has lead to overcharge the \texttt{GameScreen} for no apparent reason in addition to break the separation wanted between the view and the model logic. The last consideration is more related to practical purposes. A annoying facet of this pattern is to constantly remember to add the systems to the world and the necessary components to those systems for the entities to be correctly processed. An alternative would be the use of the dependency injection pattern. Using this pattern, we would only have to define the archetypes and specify over which archetype the systems should be processed. Then, an intermediary aware of all the elements defined by the model would simply provide the requested dependencies. \cite{wiki:dependenciesInjection}

\unnumberedSubsection[mvcImplementation]{Model-View-Controller Pattern}
Now that the model layer is almost entirely implemented using the \gls{ecs} pattern, how should we interact with this model? This is where the \gls{mvc} pattern enter in scene. For our game, we divided the controller and view layers based on a screen basis which was, in our opinion, resulting in a good and straight forward division of the responsibilities. As shown by the \autoref{fig:views} and the \autoref{fig:controllers}, we created base classes for controllers and views (\texttt{BasicController} and \texttt{BasicView}) so that common methods and attributes can be easily shared among those similar classes. In addition to the exhibiting the implementation of the \gls{mvc} pattern, the \autoref{fig:views} also expose all the dependencies of the \texttt{GameScreen} class with the user controls (joystick, bomb button and in-game settings button), the overlaying and transparent in-game settings window together with the \gls{hud}. Not shown on the figure, each view classes possess a reference over an instance of the corresponding controller. It is through this controller instance that the view classes will interact with the model no matter if it wants to send or receive information. \\

\AddPicture[controllers]{1}{0.5}{controllers.png}{Class Diagram of the \texttt{controller} Package}

There are however one important critic that can be formulate against our implementation of the \gls{mvc} pattern. First, \texttt{GameScreen} is still highly coupled with the model because the initialization of the \gls{ecs} world is performed inside its constructor. This is clearly the biggest and only flaw in our architecture. The initialization of the \gls{ecs} world should be performed inside the model layer with only the minimal calls for triggering its creation and rendering the entities should have been done using an indirection through the \texttt{GameScreenController}. \\

Another, but less dramatic critic, that is not really related to the \gls{mvc} pattern, but still part of the \texttt{views} package, it that we could have created a common parent or a single but more flexible class to avoid the code duplication for the \texttt{BombButton} and the \texttt{SettingsButton}. As we can see, their implementation is almost the same with the exception that they display a different image, they are of different size and that their listeners perform different tasks.

\AddPicture[views]{1}{1}{views.png}{Class Diagram of the \texttt{view} Package}

\unnumberedSubsection[singletonImplementation]{Singleton Pattern}
Concerning the implementation of the singleton pattern, there is nothing in particular to say. As presented by the \autoref{fig:singletons}, all classes have a static method called \texttt{getInstance} and a private constructor. All the classes also have an attribute of the same type of the class (usually called \texttt{instance}). On the first call of the \texttt{getInstance} method, if the \texttt{instance} attribute is null, the private constructor will be called to instantiate the class and it will keep a reference over the returned instance for further call. Hence, we can be insured that at most one instance will exist for a given class at any given time. We also need to precise that since the singleton class is suppose to be callable from anywhere, its constructor should be argument free. \\

We used the singleton pattern for three classes that correspond to our asset manager, our audio player and our network manager. Those three classes presents three main characteristic which was making the singleton pattern perfectly suited for their implementation. Those three characteristics are:
\begin{itemize}
  \item Need to be accessible from anywhere.
  \item The existence of another instance would generate many problems and made fail to achieve their duty.
  \item Apart from realizing specific tasks to serve client classes, those classes are not implied in any manner in the game logic.
\end{itemize}

Another class that we could have been tempted to implement using the singleton pattern is the \texttt{Gird} which allows use to positionne and detects entities during the game loop. However, this class only present one the three characteristics we just listed which the fact that the existence of another instance would create unexpected and undesirable behaviors. It is why we decided to use a single instance pattern instead. Singleton pattern should be used with parsimony and beginner programmers often tend to see them everywhere they are not. Another misleading fact that could make us think that the \texttt{Grid} should be implemented as a singleton could be the fact that we have to manually add all the \gls{ecs} factories to a hashmap in the \texttt{GameScreen} class far away from their use, but again this is only due to the bad design choice to instantiate the \gls{ecs} world into the interface... \\

In the case of the \texttt{Assets} class, the constructor do ask for an argument, but this is only because of early development stage and a private, static and final attribute as then been create in the class. This should clearly have been refactored, but we had some more important things to look at.

\AddPicture[singletons]{1}{0.5}{singletons.png}{Class Diagram of the singleton classes}

\unnumberedSubsection[observerImplementation]{Observer Pattern}
The observer pattern is indirectly used at many places in our architecture and accros all the layers. \\

Starting with the view layer, all the buttons/controls use the observer pattern to handle the event they are generating. A nice thing about the way we created those listeners is that they do not contain any logic apart from passing their status to a method specifically designed for each of them defined inside the corresponding controller of the screen. \\

In the model layer, we also defined a \texttt{TimerComponent} which act in a similar way that the observer pattern. Using this component, we can define a timer that will simply be decreased during the processing loop. When the value of this timer reach 0, then the listener\footnote{A simple wrapper for a method called \texttt{run}.} defined at the creation of the component will be use to process the event. \\

Finally, it is in the service layer that we made our more complete implementation and usage of the observer pattern. More precisely, we used this pattern inside the \texttt{networking} package which is in charge of managing the communication between the players. The \autoref{fig:networking} expose the class diagram of this package. Lets restate that networking is based on \gls{p2p} connection where different parts of the game are requiring varying information about status of the playroom and data from other players. This is why we took the initiative to implement the observer pattern. This is accomplished by the \texttt{IPlayservice} notifying the listeners interested in specific parts about the network. Per example the \texttt{NetworkManager} which is implementing the \texttt{RealTimeListener} interface need to be notified whenever the client receives data from another player to handle this information and produce the change into the model. Another example is the \texttt{WaitingroomController} that needs to be notified when the user gets connected to a room so that he can proceed to the broadcasting of the IDs between the players.

\AddPicture[singletons]{1}{0.5}{networking.png}{Class Diagram of the \texttt{networking} Package}

\unnumberedSubsection[strategyImplementation]{Strategy Pattern}
In the context of the project, we did not use a complete strategy pattern, where specialized class have as attribute behavioral interfaces instanciation. Nevertheless, we can compare the structure of the \texttt{factories} package with a variant of the strategy pattern. To create the factories and inject confer them different behavior we created three interfaces that would dictate where and how those factories can be used.
The three are placed in the middle of the \autoref{fig:factories} to make the strategy pattern easier to observe. The principal advantage of the strategy pattern is the flexibility to create classes which would have normally necessitate horizontal dependencies in a traditional hierarchical inheritance tree (which is impossible).

\AddPicture[singletons]{1}{0.5}{factories.png}{Class Diagram of the \texttt{factory} Package}

From the \autoref{fig:factories}, we can also observe the details of the \texttt{ITEM\_TYPE\_ENUM}. The use of such an enumeration allowed us to easily create new items on the fly by regrouping all the specification into this enumeration. This is the best solution we came with due to the due to the non-object oriented structure of the \gls{ecs} pattern.
By the use of this enumeration, we are able to define the icon to use and the effect of the items over the player component. Using this enumeration, creating item take about 2 minutes. However, this enumeration presents some limitations relatively to the fact that all the icons must be extracted from the same texture and that the item can only affects the player component that has to communicate its attribute to other component during the process loop. Those limitations were not considered as big deal for us. First, a new texture corresponding to the combinaison of many textures can always be created to provide more icons. Also, the way the \texttt{ItemSystem} has been designed, we were already constraint to apply change locally over the \texttt{PlayerComponent} to avoid the \texttt{ItemSystem} to have too much dependencies as the \texttt{PlayerSystem} already have and for some networking considerations as well.

\unnumberedSubsection[others]{Others}
As introduced in the architecture document, the object pooling pattern could have been really interesting especially with the use of the \gls{ecs} pattern. Some examples of object pooling that could be done to make the game even more efficient would be recuperation of the explosion entities that are frequently created and deleted during the chaining of the explosion based on the range of the character. We could also have used it for other frequent animations such as the crates and bushes destruction and even the bombs themselves.
