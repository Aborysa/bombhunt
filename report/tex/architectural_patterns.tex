\section{Architectural Patterns}
For our game we will combine several different architectural patterns, to make the game fulfill our requirements.

\subsection{Entity Component System}
Entity–component–system \cite{wiki:ecs} is an architectural pattern that is mostly used in game development. An ECS follows the Composition over inheritance principle that allows greater flexibility in defining entities.
Every game objects is represented by an entity. Each entity is composed of several components and the logic of these components is contained in systems. This means that the behaviour of an entity can change drastically by adding or removing components, without having to stick to hardcoded entities.
This pattern partially satisfies the modifiabily requirement and will make it a lot easier for us as developers to create new types of entities for our game. Instead of having to make a new entity from scratch, we can develop a single new component, add that to an entity with a combination of other components, to create a unique and possibly exciting new entity.

\subsection{Peer to Peer}
Peer-to-peer \cite{wiki:p2p} computing or networking is a distributed application architecture that partitions tasks or workloads between peers. Peers are equally privileged, equipotent participants in the application meaning they can all create and modify their own entities. When creating an entity all network components will be synchronized between the peers allowing all of them to locally simulate the entities, we'll keep track of which entities are locally created and which are remote allowing for re-synchronizing states in case where a client freezes invalidating it's local state.
It became obvious for us that a p2p connection would be more beneficial for us, as we didn't want to fully develop our own backend for handling traffic and updating the state of the game, for every game of every user. This will help us with scalability, if the game ever were to gain traction or a big playerbase in an alternative universe.
We haven't decided fully how we will set up the P2P connection, but we have looked at some alternatives for our game.
One of the alternatives was to create a nodeJS backend matchmaking server for handling Hole punching\cite{wiki:holePunching} and setting up the connections, but it looks like it might take too much time off our game. We then looked at alternatives, or existing solutions that might speed this process up a bit for us.
One of the popular ways to set up p2p for phone games, was to use Google Play Games Service. This is used to set up a P2P connection between players. Once the connection is made, the game clients synchronize the game state between each other.

\subsection{Model View Controller}
Model View Controller \cite{wiki:mvc} will be used in our application to divide up the model, and the rendering of the model, and the control of the model. This means that for instance internally the model will contain a lot of information, but nothing about how it will be displayed in the view. This makes it practical for developers if they want to completely swap out a view, or controller of a model, without having to change the model at all. This will be achieved by keeping the calls by the model itself to a minimum. The controller will use the functions of the models to change it's state and data, while the view use calls of the model to access information about what to display.
