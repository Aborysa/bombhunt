\unnumberedChapter[cotsCompTechConst]{COTS Components and Technical Constraints}

In this chapter, we will describe the constraints imposed by our choice of \gls{cots}. Among the different \gls{cots} that will be used for the development of this application, we can find \texttt{LibGDX}, \texttt{Artemis-odb}, \texttt{Android}, and \texttt{Google Play Game Services}. For each of these, the rationale behind their selection, the specific interface that we have to implement and an analysis of the constraints they add to the project will be provided.

%Describe the constraints on the architecture due to your choice of COTS. This part should specify the interfaces to COTS you must use and how the choice of COTS (e.g. Android or iOS platform) will restrict/constrain your architecture.
% State any other constraints (on the architecture) relevant for your project.

% @Erling
% Explain why we choose those COTS
% How they will be useful to the project
% Specify interfaces to COTS that we must use

% Mention the usage of Tiled to create the maps and the constraints of dynamically linking the environment entities

\unnumberedSection[libgdx]{LibGDX}
During early assignments in this course, we got to know the way \texttt{LibGDX} \citep{libgdx} can have a stack of screens, and only render and display the top one. This will constrain how we develop the way we change screens, and how we should handle dumping all entities once we drop a screen. This is important to get right as the performance might vary if this is done poorly.

\unnumberedSection[artemis]{Artemis-odb}
Since we decided to develop the core part of our game using \gls{ecs} we looked at different frameworks that already implements such system. First we looked at \texttt{Ashley} \citep{ashley} which is a sub-library of LibGDX, it is a very lightweight library that only contains the most basic aspects of ecs. Secondly we had a look at a more preferment \footnote{\url{https://github.com/junkdog/entity-system-benchmarks}} \texttt{Artemis-odb} \citep{artemis-odb}. This library is slightly more heavy weight than Ashley is, but in the end a lot easier to work with. It doesn't only implement the basics of ecs, but also implements a huge number of helper classes that for instance simplifies entity creation\footnote{\url{https://github.com/junkdog/artemis-odb/wiki/Archetype}} and modification\footnote{\url{https://github.com/junkdog/artemis-odb/wiki/Entity-Transmuter}}. ECS requires that the logic is separated from the data using systems and components. Each system performs a set of actions on a subset of all entities fulfilling a set of require components for the action to be executed. Entities are therefor just bags that holds a set of components and nothing more. In practise this means any entity can be completely change behaviour by changing the set of components it has.

\unnumberedSection[android]{Android}
One of the mayor challenges for developing a game for Android, is that the version of Android and Java might vary a lot based on what device is playing the game. We imagine we will probably just restrict the game to not work on older devices, to save ourselves some headache with trying to understand why something might not work on older devices. Another thing that will constraint how we make our game, is the difference in resolutions and hardware performance on each device. This means we will have to come up with a way to scale our \gls{ui} and on-screen elements, instead of just rendering based on a set resolution. This also means we will have to follow strict rules on how to clear unused elements in the game world, so the memory of the device doesn't get filled up.

\unnumberedSection[googlePlayGameServices]{Google Play Game Services or other solutions}
Since we want to have some service that can set up \gls{p2p} connections for us, we realize our game architecture needs to include some form of manager or handler that will communicate with this service. Assuming we use some \gls{cots} like \gls{gpgs} \citep{gpgs}, we will most likely have to follow some very strict rules that allow \gls{p2p} setups via this service. These sort of interactions will happen when a user sets up a room, when a user want to join that room and when users are restricted to join certain rooms.
