\section{Architectural Tactics}
This section outlines the architectural tactics applied in this project to meet the quality requirements.

	\subsection{Modifiability tactics}
	The goal of modifiability tactics is to lower the cost of making a change to the system. In general we define this cost as the time spent on making a change.
	
	The tactics here discussed have three main goals:
	\begin{itemize}  
		\item Localize modifications / increase cohesion
		\item Prevent ripple effects / decrease coupling
		\item Defer binding time
	\end{itemize}
	

	\begin{description}
		\item [Encapsulation]
			Placing a module behind an interface decreases the coupling between the module and those that depend on it. The implementation of the interface can be modified without having to change the modules that depend on it.
		\item [Generalizing]
			Making a more general version of a component allows to create different instances without having to modify code. For example a generalization of a method with parameters can be used in different situations to perform different tasks without needing different methods.
		\item [Preferences]
			Coding certain aspects of the game as preferences allows the developers to easily tweak the game. Some preferences can be made available to the user so the game experience can be customized to personal preferences.
		\item [Anticipate expected changes]
			We apply this tactic by asking ourselves the questions: "What changes are most likely?" and "For each change, does the proposed decomposition limit the set of modules that need to be modified to accomplish it?" Some changes are more likely than others. By anticipating what changes will be most likely to occur we can make sure that they require minimal effort.
		\item [Maintain semantic coherence]
			Semantic coherence refers to the relationships among responsibilities in a module. The goal is to ensure that all of these responsibilities work together without excessive reliance on other modules. 
		\item [Hide information]
			By only making the necessary parts of a module public, we avoid unanticipated interdependencies. This allows to split the implementation in smaller parts without having to make a lot of changes when one of these parts has to be modified.
		\item [Use an intermediary]
		When applicable we use an intermediary to convert the output of one module to the expected input of another module.
	\end{description}
	
		
	\subsection{Usability tactics}
	Usability tactics attempt to make the system easy to learn and use while offering all the required functionality. 
	
		\begin{description}
			\item[Simplicity]
			We adhere to the concept known as Occam's Razor which can be summarized as "less is more". By limiting the number of unnecessary elements and instead focusing on a simple and intuitive gameplay, we make the game easier to learn and more enjoyable for the user. Extra functionality is added in a way that adds minimal complexity.
			
			\item[Prototyping]
			A \gls{ui} that makes sense for us is not necessarily the most intuitive for all users. Thus we try to make early prototypes and get feedback from other users.
			
			\item[Using accepted standards]
			There are widely known accepted standards. Designing our \gls{ui} to conform these standards, will make new users instantly familiar with our interface. Examples of this are Google's Material Design, standard controller layout, pause menu in top right, ...
			
		\end{description}