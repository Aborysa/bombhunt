\unnumberedChapter[cotsCompTechConst]{COTS Components and Technical Constraints}

In this chapter, we will describe the constraints imposed by our choice of \gls{cots}. Among the different \gls{cots} that will be used for the development of this application, we can find \texttt{LibGDX}, \texttt{Artemis-odb}, \texttt{Android}, and \texttt{Google Play Game Services}. For each of these, the rationale behind their selection, the specific interface that we have to implement and an analysis of the constraints they add to the project will be provided.

%Describe the constraints on the architecture due to your choice of COTS. This part should specify the interfaces to COTS you must use and how the choice of COTS (e.g. Android or iOS platform) will restrict/constrain your architecture.
% State any other constraints (on the architecture) relevant for your project.

% @Jarle
% Specify interfaces to COTS that we must use


\unnumberedSection[libgdx]{LibGDX}
During early assignments in this course, we got to know the way \texttt{LibGDX} \citep{libgdx} can have a stack of screens, and only render and display the top one. This will constrain how we develop the way we change screens, and how we should handle dumping all entities once we drop a screen. This is important to get right as the performance might vary if this is done poorly.
We chose this \gls{cots} because of the intro exercises for this course, where we had to get familiar with some graphic engine. Since we all chose to make our exercises in android, and followed the suggested steps for setting up our games, we decided to stick with it in this project as well.

\unnumberedSection[tiled]{Tiled}
During the prephase of our game, we decided to make our maps tile based. Included in the LibGDX wiki, we found them using the generic tile editor \texttt{Tiled} \citep{tiled}. This allows us to create various tile based maps for our game with ease. It does however mean we have to find some open source graphic tilesets, as we have no clue how to make any decent ourselves.

\unnumberedSection[bfxr]{Bfxr}
For our game we want to include audio effects that get triggered by different kind of events. That's why we decided to try out \texttt{Bfxr} \citep{bfxr} for our project, as some group members have used it in previous game creation competitions. This \gls{cots} is a sound generator that randomly generates different sound effects, based on presets we can define. This \gls{cots} won't constrain or restrict our architechture in any way, as it just exports .wav soundfiles for us.

\unnumberedSection[artemis]{Artemis-odb}
Since we decided to develop the core part of our game using \gls{ecs} we looked at different frameworks that already implements such system. First we looked at \texttt{Ashley} \citep{ashley} which is a sub-library of LibGDX, it is a very lightweight library that only contains the most basic aspects of \gls{ecs}. Secondly we had a look at a more preferment \footnote{\url{https://github.com/junkdog/entity-system-benchmarks}} \texttt{Artemis-odb} \citep{artemis-odb}. This library is slightly more heavy weight than Ashley is, but in the end a lot easier to work with. It doesn't only implement the basics of ecs, but also implements a huge number of helper classes that for instance simplifies entity creation\footnote{\url{https://github.com/junkdog/artemis-odb/wiki/Archetype}} and modification\footnote{\url{https://github.com/junkdog/artemis-odb/wiki/Entity-Transmuter}}. ECS requires that the logic is separated from the data using systems and components. Each system performs a set of actions on a subset of all entities fulfilling a set of require components for the action to be executed. Entities are therefor just bags that holds a set of components and nothing more. In practise this means any entity can be completely change behaviour by changing the set of components it has.
We chose this \gls{cots} because of the well documented performance the framework has when used properly, as well as how well the functionality and interfaces are documented.

\unnumberedSection[android]{Android}
One of the mayor challenges for developing a game for Android, is that the version of Android and Java might vary a lot based on what device is playing the game. We imagine we will probably just restrict the game to not work on older devices, to save ourselves some headache with trying to understand why something might not work on older devices. For the moment, we are planning to support \texttt{KitKat 4.4} and later. As we can see from the \autoref{fig:androidVersions}, we can see that we will still reach more than 94\% of the market. \cite{android_2018} \\

Another thing that will constraint how we make our game, is the difference in resolutions and hardware performance on each device. This means we will have to come up with a way to scale our \gls{ui} and on-screen elements, instead of just rendering based on a set resolution. This also means we will have to follow strict rules on how to clear unused elements in the game world, so the memory of the device doesn't get filled up. \\

Everyone in the group are used to having android devices, or are able to emulate it on their computer. Since this was common ground for everyone in the group, as well how free we are to develop for android compared to ios, we decided to stay with it for this project as well.

\AddPicture[androidVersions]{1}{0.5}{androidPlateformVersion}{Current Distribution of the Android Plateform Versions}

\unnumberedSection[googlePlayGameServices]{Google Play Game Services or Other Solutions}
Since we want to have some service that can set up \gls{p2p} connections for us, we realize our game architecture needs to include some form of manager or handler that will communicate with this service. Assuming we use some \gls{cots} like \gls{gpgs} \citep{gpgs}, we will most likely have to follow some very strict rules that allow \gls{p2p} setups via this service. These sort of interactions will happen when a user sets up a room, when a user want to join that room and when users are restricted to join certain rooms.
